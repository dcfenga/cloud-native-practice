package main

import (
	"fmt"
)

/*
信道，就是一个管道，连接多个goroutine程序 ，它是一种队列式的数据结构，遵循先入先出的规则。
每个信道都只能传递一种数据类型的数据

信道声明：
var 信道实例 chan 信道类型

信道初始化：
信道实例 = make(chan 信道类型, cap int)
第一个参数：必填，指定信道类型
第二个参数：选填，不填默认为0，指定信道的容量（可缓存多少数据）

简化写法：
信道实例 := make(chan 信道类型)
*/
func main() {
	// 信道的容量与长度
	// 当容量为0时，说明信道中不能存放数据，在发送数据时，必须要求立马有人接收，否则会报错。此时的信道称之为无缓冲信道。
	// 当容量为1时，说明信道只能缓存一个数据，若信道中已有一个数据，此时再往里发送数据，会造成程序阻塞。 利用这点可以利用信道来做锁。
	// 当容量大于1时，信道中可以存放多个数据，可以用于多个协程之间的通信管道，共享资源。
	pipeline := make(chan int, 10)
	fmt.Printf("信道可缓冲 %d 个数据\n", cap(pipeline))
	pipeline <- 1
	fmt.Printf("信道中当前有 %d 个数据\n", len(pipeline))

	// 缓冲信道
	// 允许信道里存储一个或多个数据，这意味着，设置了缓冲区后，发送端和接收端可以处于异步的状态。
	pipeline2 := make(chan int, 10)
	fmt.Printf("信道可缓冲 %d 个数据\n", cap(pipeline2))

	// 无缓冲信道
	// 在信道里无法存储数据，这意味着，接收端必须先于发送端准备好，以确保你发送完数据后，有人立马接收数据，否则发送端就会造成阻塞;
	// 原因很简单，信道中无法存储数据。也就是说发送端和接收端是同步运行的。
	pipeline3 := make(chan int)
	pipeline4 := make(chan int, 0)
	fmt.Printf("信道可缓冲 %d 个数据\n", cap(pipeline3))
	fmt.Printf("信道可缓冲 %d 个数据\n", cap(pipeline4))
	fmt.Println("------------------------------------")

}
